{"version":3,"sources":["StackRouter.js"],"names":["NavigationActions","StackActions","createConfigGetter","getScreenForRouteName","StateUtils","validateRouteConfigMap","invariant","generateKey","createPathParser","behavesLikePushAction","action","type","NAVIGATE","PUSH","defaultActionCreators","isResetToRootStack","RESET","key","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","routeConfig","screen","router","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","getInitialState","route","childRouter","undefined","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","navigate","initialRouteKey","getParamsForRouteAndAction","getPathAndParamsForRoute","getActionForPathAndParams","getComponentForState","state","activeChildRoute","getComponentForRouteName","getActionCreators","navStateKey","pop","n","popToTop","push","replace","replaceWith","newKey","reset","actions","length","dismiss","back","activeChildRouter","replaceAt","SET_PARAMS","childRoute","slice","reverse","nextRouteState","newState","replaceAndPrune","immediate","lastRouteIndex","findIndex","r","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","POP_TO_TOP","REPLACE","routeIndex","COMPLETE_TRANSITION","toChildKey","lastRoute","find","indexOf","newStackActions","map","newStackAction","BACK","POP","prune","count","Math","max","concat","backRouteIndex","backRoute","keyIndex","preserveFocus","includes","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"mappings":"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","sourcesContent":["import * as NavigationActions from '../NavigationActions';\r\nimport * as StackActions from './StackActions';\r\nimport createConfigGetter from './createConfigGetter';\r\nimport getScreenForRouteName from './getScreenForRouteName';\r\nimport StateUtils from '../StateUtils';\r\nimport validateRouteConfigMap from './validateRouteConfigMap';\r\nimport invariant from '../utils/invariant';\r\nimport { generateKey } from './KeyGenerator';\r\nimport { createPathParser } from './pathUtils';\r\n\r\nfunction behavesLikePushAction(action) {\r\n  return (\r\n    action.type === NavigationActions.NAVIGATE ||\r\n    action.type === StackActions.PUSH\r\n  );\r\n}\r\n\r\nconst defaultActionCreators = () => ({});\r\n\r\nfunction isResetToRootStack(action) {\r\n  return action.type === StackActions.RESET && action.key === null;\r\n}\r\n\r\nexport default (routeConfigs, stackConfig = {}) => {\r\n  // Fail fast on invalid route definitions\r\n  validateRouteConfigMap(routeConfigs);\r\n\r\n  const childRouters = {};\r\n  const routeNames = Object.keys(routeConfigs);\r\n\r\n  // Loop through routes and find child routers\r\n  routeNames.forEach((routeName) => {\r\n    // We're not using `getScreenForRouteName` here to preserve the lazy loading\r\n    // behaviour of routes. This means that routes with child routers must be\r\n    // defined using a component directly or with an object with a screen prop.\r\n    const routeConfig = routeConfigs[routeName];\r\n    const screen =\r\n      routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\r\n    if (screen && screen.router) {\r\n      // If it has a router it's a navigator.\r\n      childRouters[routeName] = screen.router;\r\n    } else {\r\n      // If it doesn't have router it's an ordinary React component.\r\n      childRouters[routeName] = null;\r\n    }\r\n  });\r\n\r\n  const { initialRouteParams } = stackConfig;\r\n  const getCustomActionCreators =\r\n    stackConfig.getCustomActionCreators || defaultActionCreators;\r\n\r\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\r\n\r\n  const initialChildRouter = childRouters[initialRouteName];\r\n\r\n  function getInitialState(action) {\r\n    let route = {};\r\n    const childRouter = childRouters[action.routeName];\r\n\r\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\r\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\r\n      let childState = {};\r\n      // The router is null for normal leaf routes\r\n      if (childRouter !== null) {\r\n        const childAction =\r\n          action.action || NavigationActions.init({ params: action.params });\r\n        childState = childRouter.getStateForAction(childAction);\r\n      }\r\n\r\n      return {\r\n        key: 'StackRouterRoot',\r\n        isTransitioning: false,\r\n        index: 0,\r\n        routes: [\r\n          {\r\n            params: action.params,\r\n            ...childState,\r\n            key: action.key || generateKey(),\r\n            routeName: action.routeName,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n\r\n    if (initialChildRouter) {\r\n      route = initialChildRouter.getStateForAction(\r\n        NavigationActions.navigate({\r\n          routeName: initialRouteName,\r\n          params: initialRouteParams,\r\n        })\r\n      );\r\n    }\r\n    const params = (routeConfigs[initialRouteName].params ||\r\n      route.params ||\r\n      action.params ||\r\n      initialRouteParams) && {\r\n      ...(routeConfigs[initialRouteName].params || {}),\r\n      ...(route.params || {}),\r\n      ...(action.params || {}),\r\n      ...(initialRouteParams || {}),\r\n    };\r\n    const { initialRouteKey } = stackConfig;\r\n    route = {\r\n      ...route,\r\n      ...(params ? { params } : {}),\r\n      routeName: initialRouteName,\r\n      key: action.key || initialRouteKey || generateKey(),\r\n    };\r\n    return {\r\n      key: 'StackRouterRoot',\r\n      isTransitioning: false,\r\n      index: 0,\r\n      routes: [route],\r\n    };\r\n  }\r\n\r\n  function getParamsForRouteAndAction(routeName, action) {\r\n    let routeConfig = routeConfigs[routeName];\r\n    if (routeConfig && routeConfig.params) {\r\n      return { ...routeConfig.params, ...action.params };\r\n    } else {\r\n      return action.params;\r\n    }\r\n  }\r\n\r\n  const {\r\n    getPathAndParamsForRoute,\r\n    getActionForPathAndParams,\r\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\r\n\r\n  return {\r\n    childRouters,\r\n\r\n    getComponentForState(state) {\r\n      const activeChildRoute = state.routes[state.index];\r\n      const { routeName } = activeChildRoute;\r\n      if (childRouters[routeName]) {\r\n        return childRouters[routeName].getComponentForState(activeChildRoute);\r\n      }\r\n      return getScreenForRouteName(routeConfigs, routeName);\r\n    },\r\n\r\n    getComponentForRouteName(routeName) {\r\n      return getScreenForRouteName(routeConfigs, routeName);\r\n    },\r\n\r\n    getActionCreators(route, navStateKey) {\r\n      return {\r\n        ...getCustomActionCreators(route, navStateKey),\r\n        pop: (n, params) =>\r\n          StackActions.pop({\r\n            n,\r\n            ...params,\r\n          }),\r\n        popToTop: (params) => StackActions.popToTop(params),\r\n        push: (routeName, params, action) =>\r\n          StackActions.push({\r\n            routeName,\r\n            params,\r\n            action,\r\n          }),\r\n        replace: (replaceWith, params, action, newKey) => {\r\n          if (typeof replaceWith === 'string') {\r\n            return StackActions.replace({\r\n              routeName: replaceWith,\r\n              params,\r\n              action,\r\n              key: route.key,\r\n              newKey,\r\n            });\r\n          }\r\n          invariant(\r\n            typeof replaceWith === 'object',\r\n            'Must replaceWith an object or a string'\r\n          );\r\n          invariant(\r\n            params == null,\r\n            'Params must not be provided to .replace() when specifying an object'\r\n          );\r\n          invariant(\r\n            action == null,\r\n            'Child action must not be provided to .replace() when specifying an object'\r\n          );\r\n          invariant(\r\n            newKey == null,\r\n            'Child action must not be provided to .replace() when specifying an object'\r\n          );\r\n          return StackActions.replace(replaceWith);\r\n        },\r\n        reset: (actions, index) =>\r\n          StackActions.reset({\r\n            actions,\r\n            index: index == null ? actions.length - 1 : index,\r\n            key: navStateKey,\r\n          }),\r\n        dismiss: () =>\r\n          NavigationActions.back({\r\n            key: navStateKey,\r\n          }),\r\n      };\r\n    },\r\n\r\n    getStateForAction(action, state) {\r\n      // Set up the initial state if needed\r\n      if (!state) {\r\n        return getInitialState(action);\r\n      }\r\n\r\n      const activeChildRoute = state.routes[state.index];\r\n\r\n      if (\r\n        !isResetToRootStack(action) &&\r\n        action.type !== NavigationActions.NAVIGATE\r\n      ) {\r\n        // Let the active child router handle the action\r\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\r\n        if (activeChildRouter) {\r\n          const route = activeChildRouter.getStateForAction(\r\n            action,\r\n            activeChildRoute\r\n          );\r\n          if (route !== null && route !== activeChildRoute) {\r\n            return StateUtils.replaceAt(\r\n              state,\r\n              activeChildRoute.key,\r\n              route,\r\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\r\n              action.type === NavigationActions.SET_PARAMS\r\n            );\r\n          }\r\n        }\r\n      } else if (action.type === NavigationActions.NAVIGATE) {\r\n        // Traverse routes from the top of the stack to the bottom, so the\r\n        // active route has the first opportunity, then the one before it, etc.\r\n\r\n        for (let childRoute of state.routes.slice().reverse()) {\r\n          let childRouter = childRouters[childRoute.routeName];\r\n          let childAction =\r\n            action.routeName === childRoute.routeName && action.action\r\n              ? action.action\r\n              : action;\r\n\r\n          if (childRouter) {\r\n            const nextRouteState = childRouter.getStateForAction(\r\n              childAction,\r\n              childRoute\r\n            );\r\n\r\n            if (nextRouteState === null || nextRouteState !== childRoute) {\r\n              const newState = StateUtils.replaceAndPrune(\r\n                state,\r\n                nextRouteState ? nextRouteState.key : childRoute.key,\r\n                nextRouteState ? nextRouteState : childRoute\r\n              );\r\n              return {\r\n                ...newState,\r\n                isTransitioning:\r\n                  state.index !== newState.index\r\n                    ? action.immediate !== true\r\n                    : state.isTransitioning,\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Handle push and navigate actions. This must happen after the focused\r\n      // child router has had a chance to handle the action.\r\n      if (\r\n        behavesLikePushAction(action) &&\r\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\r\n      ) {\r\n        const childRouter = childRouters[action.routeName];\r\n        let route;\r\n\r\n        invariant(\r\n          action.type !== StackActions.PUSH || action.key == null,\r\n          'StackRouter does not support key on the push action'\r\n        );\r\n\r\n        // Before pushing a new route we first try to find one in the existing route stack\r\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\r\n        const lastRouteIndex = state.routes.findIndex((r) => {\r\n          if (action.key) {\r\n            return r.key === action.key;\r\n          } else {\r\n            return r.routeName === action.routeName;\r\n          }\r\n        });\r\n\r\n        // An instance of this route exists already and we're dealing with a navigate action\r\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\r\n          // If index is unchanged and params are not being set, leave state identity intact\r\n          if (state.index === lastRouteIndex && !action.params) {\r\n            return null;\r\n          }\r\n\r\n          // Remove the now unused routes at the tail of the routes array\r\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\r\n\r\n          // Apply params if provided, otherwise leave route identity intact\r\n          if (action.params) {\r\n            const route = state.routes[lastRouteIndex];\r\n            routes[lastRouteIndex] = {\r\n              ...route,\r\n              params: {\r\n                ...route.params,\r\n                ...action.params,\r\n              },\r\n            };\r\n          }\r\n          // Return state with new index. Change isTransitioning only if index has changed\r\n          return {\r\n            ...state,\r\n            isTransitioning:\r\n              state.index !== lastRouteIndex\r\n                ? action.immediate !== true\r\n                : state.isTransitioning,\r\n            index: lastRouteIndex,\r\n            routes,\r\n          };\r\n        }\r\n\r\n        if (childRouter) {\r\n          // Delegate to the child router with the given action, or init it\r\n          const childAction =\r\n            action.action ||\r\n            NavigationActions.init({\r\n              params: getParamsForRouteAndAction(action.routeName, action),\r\n            });\r\n          route = {\r\n            params: getParamsForRouteAndAction(action.routeName, action),\r\n            // note(brentvatne): does it make sense to wipe out the params\r\n            // here? or even to add params at all? need more info about what\r\n            // this solves\r\n            ...childRouter.getStateForAction(childAction),\r\n            routeName: action.routeName,\r\n            key: action.key || generateKey(),\r\n          };\r\n        } else {\r\n          // Create the route from scratch\r\n          route = {\r\n            params: getParamsForRouteAndAction(action.routeName, action),\r\n            routeName: action.routeName,\r\n            key: action.key || generateKey(),\r\n          };\r\n        }\r\n        return {\r\n          ...StateUtils.push(state, route),\r\n          isTransitioning: action.immediate !== true,\r\n        };\r\n      } else if (\r\n        action.type === StackActions.PUSH &&\r\n        childRouters[action.routeName] === undefined\r\n      ) {\r\n        // Return the state identity to bubble the action up\r\n        return state;\r\n      }\r\n\r\n      // Handle navigation to other child routers that are not yet pushed\r\n      if (behavesLikePushAction(action)) {\r\n        const childRouterNames = Object.keys(childRouters);\r\n        for (let i = 0; i < childRouterNames.length; i++) {\r\n          const childRouterName = childRouterNames[i];\r\n          const childRouter = childRouters[childRouterName];\r\n          if (childRouter) {\r\n            // For each child router, start with a blank state\r\n            const initChildRoute = childRouter.getStateForAction(\r\n              NavigationActions.init()\r\n            );\r\n            // Then check to see if the router handles our navigate action\r\n            const navigatedChildRoute = childRouter.getStateForAction(\r\n              action,\r\n              initChildRoute\r\n            );\r\n            let routeToPush = null;\r\n            if (navigatedChildRoute === null) {\r\n              // Push the route if the router has 'handled' the action and returned null\r\n              routeToPush = initChildRoute;\r\n            } else if (navigatedChildRoute !== initChildRoute) {\r\n              // Push the route if the state has changed in response to this navigation\r\n              routeToPush = navigatedChildRoute;\r\n            }\r\n            if (routeToPush) {\r\n              const route = {\r\n                ...routeToPush,\r\n                routeName: childRouterName,\r\n                key: action.key || generateKey(),\r\n              };\r\n              return {\r\n                ...StateUtils.push(state, route),\r\n                isTransitioning: action.immediate !== true,\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\r\n      if (action.type === StackActions.POP_TO_TOP) {\r\n        // Refuse to handle pop to top if a key is given that doesn't correspond\r\n        // to this router\r\n        if (action.key && state.key !== action.key) {\r\n          return state;\r\n        }\r\n\r\n        // If we're already at the top, then we return the state with a new\r\n        // identity so that the action is handled by this router.\r\n        if (state.index > 0) {\r\n          return {\r\n            ...state,\r\n            isTransitioning: action.immediate !== true,\r\n            index: 0,\r\n            routes: [state.routes[0]],\r\n          };\r\n        }\r\n        return state;\r\n      }\r\n\r\n      // Handle replace action\r\n      if (action.type === StackActions.REPLACE) {\r\n        let routeIndex;\r\n\r\n        // If the key param is undefined, set the index to the last route in the stack\r\n        if (action.key === undefined && state.routes.length) {\r\n          routeIndex = state.routes.length - 1;\r\n        } else {\r\n          routeIndex = state.routes.findIndex((r) => r.key === action.key);\r\n        }\r\n\r\n        // Only replace if the key matches one of our routes\r\n        if (routeIndex !== -1) {\r\n          const childRouter = childRouters[action.routeName];\r\n          let childState = {};\r\n          if (childRouter) {\r\n            const childAction =\r\n              action.action ||\r\n              NavigationActions.init({\r\n                params: getParamsForRouteAndAction(action.routeName, action),\r\n              });\r\n            childState = childRouter.getStateForAction(childAction);\r\n          }\r\n          const routes = [...state.routes];\r\n          routes[routeIndex] = {\r\n            params: getParamsForRouteAndAction(action.routeName, action),\r\n            // merge the child state in this order to allow params override\r\n            ...childState,\r\n            routeName: action.routeName,\r\n            key: action.newKey || generateKey(),\r\n          };\r\n          return { ...state, routes };\r\n        }\r\n      }\r\n\r\n      // Update transitioning state\r\n      if (\r\n        action.type === StackActions.COMPLETE_TRANSITION &&\r\n        (action.key == null || action.key === state.key) &&\r\n        action.toChildKey === state.routes[state.index].key &&\r\n        state.isTransitioning\r\n      ) {\r\n        return {\r\n          ...state,\r\n          isTransitioning: false,\r\n        };\r\n      }\r\n\r\n      if (action.type === NavigationActions.SET_PARAMS) {\r\n        const key = action.key;\r\n        const lastRoute = state.routes.find((route) => route.key === key);\r\n        if (lastRoute) {\r\n          const params = {\r\n            ...lastRoute.params,\r\n            ...action.params,\r\n          };\r\n          const routes = [...state.routes];\r\n          routes[state.routes.indexOf(lastRoute)] = {\r\n            ...lastRoute,\r\n            params,\r\n          };\r\n          return {\r\n            ...state,\r\n            routes,\r\n          };\r\n        }\r\n      }\r\n\r\n      if (action.type === StackActions.RESET) {\r\n        // Only handle reset actions that are unspecified or match this state key\r\n        if (action.key != null && action.key !== state.key) {\r\n          // Deliberately use != instead of !== so we can match null with\r\n          // undefined on either the state or the action\r\n          return state;\r\n        }\r\n        const newStackActions = action.actions;\r\n\r\n        return {\r\n          ...state,\r\n          routes: newStackActions.map((newStackAction) => {\r\n            const router = childRouters[newStackAction.routeName];\r\n\r\n            let childState = {};\r\n\r\n            if (router) {\r\n              const childAction =\r\n                newStackAction.action ||\r\n                NavigationActions.init({\r\n                  params: getParamsForRouteAndAction(\r\n                    newStackAction.routeName,\r\n                    newStackAction\r\n                  ),\r\n                });\r\n\r\n              childState = router.getStateForAction(childAction);\r\n            }\r\n\r\n            return {\r\n              params: getParamsForRouteAndAction(\r\n                newStackAction.routeName,\r\n                newStackAction\r\n              ),\r\n              ...childState,\r\n              routeName: newStackAction.routeName,\r\n              key: newStackAction.key || generateKey(),\r\n            };\r\n          }),\r\n          index: action.index,\r\n        };\r\n      }\r\n\r\n      if (\r\n        action.type === NavigationActions.BACK ||\r\n        action.type === StackActions.POP\r\n      ) {\r\n        const { key, n, immediate, prune } = action;\r\n\r\n        if (action.type === StackActions.POP && prune === false && key) {\r\n          const index = state.routes.findIndex((r) => r.key === key);\r\n\r\n          if (index > 0) {\r\n            const count = Math.max(index - (n ?? 1) + 1, 1);\r\n            const routes = state.routes\r\n              .slice(0, count)\r\n              .concat(state.routes.slice(index + 1));\r\n\r\n            if (routes.length) {\r\n              return {\r\n                ...state,\r\n                routes,\r\n                index: routes.length - 1,\r\n                isTransitioning: immediate !== true,\r\n              };\r\n            }\r\n          }\r\n        } else {\r\n          let backRouteIndex = state.index;\r\n\r\n          if (action.type === StackActions.POP && n != null) {\r\n            // determine the index to go back *from*. In this case, n=1 means to go\r\n            // back from state.index, as if it were a normal \"BACK\" action\r\n            backRouteIndex = Math.max(1, state.index - n + 1);\r\n          } else if (key) {\r\n            const backRoute = state.routes.find((route) => route.key === key);\r\n            backRouteIndex = state.routes.indexOf(backRoute);\r\n          }\r\n\r\n          if (backRouteIndex > 0) {\r\n            return {\r\n              ...state,\r\n              routes: state.routes.slice(0, backRouteIndex),\r\n              index: backRouteIndex - 1,\r\n              isTransitioning: immediate !== true,\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\r\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\r\n\r\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\r\n\r\n      // Traverse routes from the top of the stack to the bottom, so the\r\n      // active route has the first opportunity, then the one before it, etc.\r\n      for (let childRoute of state.routes.slice().reverse()) {\r\n        if (childRoute.key === activeChildRoute.key) {\r\n          // skip over the active child because we let it attempt to handle the action earlier\r\n          continue;\r\n        }\r\n        // If a key is provided and in routes state then let's use that\r\n        // knowledge to skip extra getStateForAction calls on other child\r\n        // routers\r\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\r\n          continue;\r\n        }\r\n        let childRouter = childRouters[childRoute.routeName];\r\n        if (childRouter) {\r\n          const route = childRouter.getStateForAction(action, childRoute);\r\n\r\n          if (route === null) {\r\n            return state;\r\n          } else if (route && route !== childRoute) {\r\n            return StateUtils.replaceAt(\r\n              state,\r\n              childRoute.key,\r\n              route,\r\n              // People don't expect these actions to switch the active route\r\n              // TODO: We should switch to action.preserveFocus: true for drawer in future\r\n              action.preserveFocus || action.type.includes('DRAWER')\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      return state;\r\n    },\r\n\r\n    getPathAndParamsForState(state) {\r\n      const route = state.routes[state.index];\r\n      return getPathAndParamsForRoute(route);\r\n    },\r\n\r\n    getActionForPathAndParams(path, params) {\r\n      return getActionForPathAndParams(path, params);\r\n    },\r\n\r\n    getScreenOptions: createConfigGetter(\r\n      routeConfigs,\r\n      stackConfig.defaultNavigationOptions\r\n    ),\r\n  };\r\n};\r\n"]}