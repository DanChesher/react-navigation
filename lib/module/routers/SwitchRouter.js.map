{"version":3,"sources":["SwitchRouter.js"],"names":["invariant","getScreenForRouteName","createConfigGetter","NavigationActions","SwitchActions","StackActions","validateRouteConfigMap","createPathParser","defaultActionCreators","routeConfigs","config","order","Object","keys","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","Error","map","n","join","childRouters","forEach","routeName","screen","router","getParamsForRoute","params","routeConfig","getPathAndParamsForRoute","getActionForPathAndParams","resetChildRoute","initialParams","childRouter","childAction","init","getStateForAction","key","getNextState","action","prevState","possibleNextState","updateNextStateHistory","nextState","index","nextRouteKeyHistory","routeKeyHistory","type","NAVIGATE","keyToAdd","routes","filter","k","push","BACK","pop","prevRouteName","nextRoutes","getInitialState","initialState","initialKey","getActionCreators","route","stateKey","inputState","state","activeChildIndex","INIT","JUMP_TO","findIndex","i","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","max","length","routeKey","didNavigate","find","childId","childState","newChildState","childStateUpdate","SET_PARAMS","lastRoute","isActionBackOrPop","POP","POP_TO_TOP","sendActionToInactiveChildren","preserveFocus","getComponentForState","getComponentForRouteName","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\r\nimport getScreenForRouteName from './getScreenForRouteName';\r\nimport createConfigGetter from './createConfigGetter';\r\n\r\nimport * as NavigationActions from '../NavigationActions';\r\nimport * as SwitchActions from './SwitchActions';\r\nimport * as StackActions from './StackActions';\r\nimport validateRouteConfigMap from './validateRouteConfigMap';\r\nimport { createPathParser } from './pathUtils';\r\n\r\nconst defaultActionCreators = () => ({});\r\n\r\nexport default (routeConfigs, config = {}) => {\r\n  // Fail fast on invalid route definitions\r\n  validateRouteConfigMap(routeConfigs);\r\n\r\n  const order = config.order || Object.keys(routeConfigs);\r\n\r\n  const getCustomActionCreators =\r\n    config.getCustomActionCreators || defaultActionCreators;\r\n\r\n  const { initialRouteParams } = config;\r\n  const initialRouteName = config.initialRouteName || order[0];\r\n  const backBehavior = config.backBehavior || 'none';\r\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\r\n    ? config.resetOnBlur\r\n    : true;\r\n\r\n  const initialRouteIndex = order.indexOf(initialRouteName);\r\n  if (initialRouteIndex === -1) {\r\n    throw new Error(\r\n      `Invalid initialRouteName '${initialRouteName}'.` +\r\n        `Should be one of ${order.map((n) => `\"${n}\"`).join(', ')}`\r\n    );\r\n  }\r\n\r\n  const childRouters = {};\r\n  order.forEach((routeName) => {\r\n    childRouters[routeName] = null;\r\n    const screen = getScreenForRouteName(routeConfigs, routeName);\r\n    if (screen.router) {\r\n      childRouters[routeName] = screen.router;\r\n    }\r\n  });\r\n\r\n  function getParamsForRoute(routeName, params) {\r\n    let routeConfig = routeConfigs[routeName];\r\n    if (routeConfig && routeConfig.params) {\r\n      return { ...routeConfig.params, ...params };\r\n    } else {\r\n      return params;\r\n    }\r\n  }\r\n\r\n  const {\r\n    getPathAndParamsForRoute,\r\n    getActionForPathAndParams,\r\n  } = createPathParser(childRouters, routeConfigs, config);\r\n\r\n  function resetChildRoute(routeName) {\r\n    let initialParams =\r\n      routeName === initialRouteName ? initialRouteParams : null;\r\n    // note(brentvatne): merging initialRouteParams *on top* of default params\r\n    // on the route seems incorrect but it's consistent with existing behavior\r\n    // in stackrouter\r\n    let params = getParamsForRoute(routeName, initialParams);\r\n    const childRouter = childRouters[routeName];\r\n    if (childRouter) {\r\n      const childAction = NavigationActions.init();\r\n      return {\r\n        ...childRouter.getStateForAction(childAction),\r\n        key: routeName,\r\n        routeName,\r\n        ...(params ? { params } : {}),\r\n      };\r\n    }\r\n    return {\r\n      key: routeName,\r\n      routeName,\r\n      ...(params ? { params } : {}),\r\n    };\r\n  }\r\n\r\n  function getNextState(action, prevState, possibleNextState) {\r\n    function updateNextStateHistory(prevState, nextState) {\r\n      if (\r\n        backBehavior !== 'history' ||\r\n        (prevState && nextState && nextState.index === prevState.index)\r\n      ) {\r\n        return nextState;\r\n      }\r\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\r\n      if (action.type === NavigationActions.NAVIGATE) {\r\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\r\n        const keyToAdd = nextState.routes[nextState.index].key;\r\n        nextRouteKeyHistory = nextRouteKeyHistory.filter((k) => k !== keyToAdd); // dedup\r\n        nextRouteKeyHistory.push(keyToAdd);\r\n      } else if (action.type === NavigationActions.BACK) {\r\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\r\n        nextRouteKeyHistory.pop();\r\n      }\r\n      return {\r\n        ...nextState,\r\n        routeKeyHistory: nextRouteKeyHistory,\r\n      };\r\n    }\r\n\r\n    let nextState = possibleNextState;\r\n    if (\r\n      prevState &&\r\n      possibleNextState &&\r\n      prevState.index !== possibleNextState.index &&\r\n      resetOnBlur\r\n    ) {\r\n      const prevRouteName = prevState.routes[prevState.index].routeName;\r\n      const nextRoutes = [...possibleNextState.routes];\r\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\r\n      nextState = {\r\n        ...possibleNextState,\r\n        routes: nextRoutes,\r\n      };\r\n    }\r\n    return updateNextStateHistory(prevState, nextState);\r\n  }\r\n\r\n  function getInitialState() {\r\n    const routes = order.map(resetChildRoute);\r\n    const initialState = {\r\n      routes,\r\n      index: initialRouteIndex,\r\n    };\r\n\r\n    if (backBehavior === 'history') {\r\n      const initialKey = routes[initialRouteIndex].key;\r\n      initialState['routeKeyHistory'] = [initialKey];\r\n    }\r\n    return initialState;\r\n  }\r\n\r\n  return {\r\n    childRouters,\r\n\r\n    getActionCreators(route, stateKey) {\r\n      return getCustomActionCreators(route, stateKey);\r\n    },\r\n\r\n    getStateForAction(action, inputState) {\r\n      let prevState = inputState ? { ...inputState } : inputState;\r\n      let state = inputState || getInitialState();\r\n      let activeChildIndex = state.index;\r\n\r\n      if (action.type === NavigationActions.INIT) {\r\n        // NOTE(brentvatne): this seems weird... why are we merging these\r\n        // params into child routes?\r\n        // ---------------------------------------------------------------\r\n        // Merge any params from the action into all the child routes\r\n        const { params } = action;\r\n        if (params) {\r\n          state.routes = state.routes.map((route) => ({\r\n            ...route,\r\n            params: {\r\n              ...route.params,\r\n              ...params,\r\n              ...(route.routeName === initialRouteName\r\n                ? initialRouteParams\r\n                : null),\r\n            },\r\n          }));\r\n        }\r\n      }\r\n\r\n      if (\r\n        action.type === SwitchActions.JUMP_TO &&\r\n        (action.key == null || action.key === state.key)\r\n      ) {\r\n        const { params } = action;\r\n        const index = state.routes.findIndex(\r\n          (route) => route.routeName === action.routeName\r\n        );\r\n\r\n        if (index === -1) {\r\n          throw new Error(\r\n            `There is no route named '${action.routeName}' in the navigator with the key '${action.key}'.\\n` +\r\n              `Must be one of: ${state.routes\r\n                .map((route) => `'${route.routeName}'`)\r\n                .join(',')}`\r\n          );\r\n        }\r\n\r\n        return getNextState(action, prevState, {\r\n          ...state,\r\n          routes: params\r\n            ? state.routes.map((route, i) =>\r\n                i === index\r\n                  ? {\r\n                      ...route,\r\n                      params: {\r\n                        ...route.params,\r\n                        ...params,\r\n                      },\r\n                    }\r\n                  : route\r\n              )\r\n            : state.routes,\r\n          index,\r\n        });\r\n      }\r\n\r\n      // Let the current child handle it\r\n      const activeChildLastState = state.routes[state.index];\r\n      const activeChildRouter = childRouters[order[state.index]];\r\n      if (activeChildRouter) {\r\n        const activeChildState = activeChildRouter.getStateForAction(\r\n          action,\r\n          activeChildLastState\r\n        );\r\n        if (!activeChildState && inputState) {\r\n          return null;\r\n        }\r\n        if (activeChildState && activeChildState !== activeChildLastState) {\r\n          const routes = [...state.routes];\r\n          routes[state.index] = activeChildState;\r\n          return getNextState(action, prevState, {\r\n            ...state,\r\n            routes,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Handle tab changing. Do this after letting the current tab try to\r\n      // handle the action, to allow inner children to change first\r\n      const isBackEligible =\r\n        action.key == null || action.key === activeChildLastState.key;\r\n      if (action.type === NavigationActions.BACK) {\r\n        if (isBackEligible && backBehavior === 'initialRoute') {\r\n          activeChildIndex = initialRouteIndex;\r\n        } else if (isBackEligible && backBehavior === 'order') {\r\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\r\n        }\r\n        // The history contains current route, so we can only go back\r\n        // if there is more than one item in the history\r\n        else if (\r\n          isBackEligible &&\r\n          backBehavior === 'history' &&\r\n          state.routeKeyHistory.length > 1\r\n        ) {\r\n          const routeKey =\r\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\r\n          activeChildIndex = order.indexOf(routeKey);\r\n        }\r\n      }\r\n\r\n      let didNavigate = false;\r\n      if (action.type === NavigationActions.NAVIGATE) {\r\n        didNavigate = !!order.find((childId, i) => {\r\n          if (childId === action.routeName) {\r\n            activeChildIndex = i;\r\n            return true;\r\n          }\r\n          return false;\r\n        });\r\n        if (didNavigate) {\r\n          const childState = state.routes[activeChildIndex];\r\n          const childRouter = childRouters[action.routeName];\r\n          let newChildState = childState;\r\n\r\n          if (action.action && childRouter) {\r\n            const childStateUpdate = childRouter.getStateForAction(\r\n              action.action,\r\n              childState\r\n            );\r\n            if (childStateUpdate) {\r\n              newChildState = childStateUpdate;\r\n            }\r\n          }\r\n\r\n          if (action.params) {\r\n            newChildState = {\r\n              ...newChildState,\r\n              params: {\r\n                ...(newChildState.params || {}),\r\n                ...action.params,\r\n              },\r\n            };\r\n          }\r\n\r\n          if (newChildState !== childState) {\r\n            const routes = [...state.routes];\r\n            routes[activeChildIndex] = newChildState;\r\n            const nextState = {\r\n              ...state,\r\n              routes,\r\n              index: activeChildIndex,\r\n            };\r\n            return getNextState(action, prevState, nextState);\r\n          } else if (\r\n            newChildState === childState &&\r\n            state.index === activeChildIndex &&\r\n            prevState\r\n          ) {\r\n            return null;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (action.type === NavigationActions.SET_PARAMS) {\r\n        const key = action.key;\r\n        const lastRoute = state.routes.find((route) => route.key === key);\r\n        if (lastRoute) {\r\n          const params = {\r\n            ...lastRoute.params,\r\n            ...action.params,\r\n          };\r\n          const routes = [...state.routes];\r\n          routes[state.routes.indexOf(lastRoute)] = {\r\n            ...lastRoute,\r\n            params,\r\n          };\r\n          return getNextState(action, prevState, {\r\n            ...state,\r\n            routes,\r\n          });\r\n        }\r\n      }\r\n\r\n      if (activeChildIndex !== state.index) {\r\n        return getNextState(action, prevState, {\r\n          ...state,\r\n          index: activeChildIndex,\r\n        });\r\n      } else if (didNavigate && !inputState) {\r\n        return state;\r\n      } else if (didNavigate) {\r\n        return { ...state };\r\n      }\r\n\r\n      const isActionBackOrPop =\r\n        action.type === NavigationActions.BACK ||\r\n        action.type === StackActions.POP ||\r\n        action.type === StackActions.POP_TO_TOP;\r\n      const sendActionToInactiveChildren =\r\n        !isActionBackOrPop ||\r\n        (action.type === NavigationActions.BACK && action.key != null);\r\n\r\n      // Let other children handle it and switch to the first child that returns a new state\r\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\r\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\r\n      if (sendActionToInactiveChildren) {\r\n        let index = state.index;\r\n        let routes = state.routes;\r\n        order.find((childId, i) => {\r\n          const childRouter = childRouters[childId];\r\n          if (i === index) {\r\n            return false;\r\n          }\r\n          let childState = routes[i];\r\n          if (childRouter) {\r\n            childState = childRouter.getStateForAction(action, childState);\r\n          }\r\n          if (!childState) {\r\n            index = i;\r\n            return true;\r\n          }\r\n          if (childState !== routes[i]) {\r\n            routes = [...routes];\r\n            routes[i] = childState;\r\n            index = i;\r\n            return true;\r\n          }\r\n          return false;\r\n        });\r\n\r\n        // Nested routers can be updated after switching children with actions such as SET_PARAMS\r\n        // and COMPLETE_TRANSITION.\r\n        if (action.preserveFocus) {\r\n          index = state.index;\r\n        }\r\n\r\n        if (index !== state.index || routes !== state.routes) {\r\n          return getNextState(action, prevState, {\r\n            ...state,\r\n            index,\r\n            routes,\r\n          });\r\n        }\r\n      }\r\n\r\n      return state;\r\n    },\r\n\r\n    getComponentForState(state) {\r\n      const routeName = state.routes[state.index].routeName;\r\n      invariant(\r\n        routeName,\r\n        `There is no route defined for index ${state.index}. Check that\r\n        that you passed in a navigation state with a valid tab/screen index.`\r\n      );\r\n      const childRouter = childRouters[routeName];\r\n      if (childRouter) {\r\n        return childRouter.getComponentForState(state.routes[state.index]);\r\n      }\r\n      return getScreenForRouteName(routeConfigs, routeName);\r\n    },\r\n\r\n    getComponentForRouteName(routeName) {\r\n      return getScreenForRouteName(routeConfigs, routeName);\r\n    },\r\n\r\n    getPathAndParamsForState(state) {\r\n      const route = state.routes[state.index];\r\n      return getPathAndParamsForRoute(route);\r\n    },\r\n\r\n    getActionForPathAndParams(path, params) {\r\n      return getActionForPathAndParams(path, params);\r\n    },\r\n\r\n    getScreenOptions: createConfigGetter(\r\n      routeConfigs,\r\n      config.defaultNavigationOptions\r\n    ),\r\n  };\r\n};\r\n"]}